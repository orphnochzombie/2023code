## AC891~894 Nim游戏合集

### [891. Nim游戏 - AcWing题库](https://www.acwing.com/problem/content/893/)

#### 原理：

首先复习一下位运算

```c++
//与运算 &
0 & 0 = 0;
0 & 1 = 0;
1 & 0 = 0; 
1 & 1 = 1; //有点像完美主义者，全为真才能真,是理想人生
```

```c++
//或运算 |
0 | 0 = 0;
0 | 1 = 1;
1 | 0 = 1;
1 | 1 = 1;  //只要有一项成功就算成功，这才是真实的人生
```

```c++
//异或运算 ^
0 ^ 0 = 0;
0 ^ 1 = 1;
1 ^ 0 = 1;
1 ^ 1 = 0; //与众不同才是真！
```



##### NIM游戏为什么用异或解决？

```c++
假设目前有两堆石子 分别为 2 2 
那么无论先手者如何拿走石子，对方只需要“镜像操作”就可以赢。
也即先手必败。
    
所以先手必败的数学推导就是
假设有n堆石子，数量分别为a1 a2 …… an
a1 ^ a2 ^ …… ^ an = 0时，先手必败（怎么取都输）。
a1 ^ a2 ^ …… ^ an != 0时，先手必胜（必须取走特定数量x）。
    
而且利用反证法可以证明:
    a1 ^ a2 ^ …^ ai ^ … ^ an = 0时，无论从 哪一堆里取走多少石子，都会使 a1 ^ a2 ^ …^ ai ^ … ^ an ！= 0。
        

```

```c++
反证如下：a1 ^ a2 ^ … ^ ai ^ … ^ an = 0 ①
    	从ai里取走x个石头，ai变为ai'
        若a1 ^ a2 ^ …^ ai' ^ … ^ an = 0 ②
        则取① ^ ② = 0，可推出 ai ^ ai' = 0
        推出ai = ai',即取出0个石子，而题给条件不能不取
        因此 当 a1 ^ a2 ^ …… ^ an = 0时，无论怎么取，先手必败。
```



##### 取走多少个才能必胜？

取走ai - ai ^ x个

```c++
当a1 ^ a2 ^ … ^ ai ^ … ^ an = x != 0时
x的二进制表示中最高一位在第k位，则a1~an中至少有一个数ai，ai的第k位是1
且ai ^ x < ai
这时候要取走的数目x = ai - ai ^ x
这样ai' = ai - x  = ai ^ x
a1 ^ a2 ^ … ^ ai' ^ … ^ an = 
a1 ^ a2 ^ … ^ ai ^ x ^ … ^ an = x ^ x = 0 必败！
```



#### 代码：

```c++
#include<iostream>
#include<algorithm>

using namespace std;

int main(){
    int n;
    scanf("%d",&n);
    int res = 0;
    
    while(n--){
        int x;
        scanf("%d",&x);
        res ^= x;
    }
    if(res != 0) cout << "Yes" << endl;
    else cout << "No" << endl;
    return 0;
    
}
```





### [892. 台阶-Nim游戏 - AcWing题库](https://www.acwing.com/problem/content/894/)

对奇数阶的石子异或可以转换成经典的Nim游戏。

偶数阶的移动到下一阶（奇数阶）时，将移动的这部分再往下移动一阶（偶数阶），这样奇数阶的石子是没有变化的，即对赢游戏没有任何帮助。

转载大佬们的理解：

（大佬A）大佬只看奇数台阶是因为这样的话，因为偶数台阶的数不看，就可以当做是地面，那么从奇数台阶往下拿就可以看成是将石子放到地面，从偶数台阶往下拿就相当于往奇数台阶上加石子，问题转换成了上一题的Nim模型。之所以选奇数台阶而不是偶数台阶是因为，奇数台阶1邻接的就是地面，这样的话将地面和偶数台阶划分到了一类中。



（大佬B）我是这样理解的，移动偶数级台阶的石子是没有意义的，比如我把第二级的石头移到第一级，对方又可以把其再移动到地面上，因此这对我取胜是没有帮助的，移动了也等于没有移动，但如果我移动的是奇数级台阶上的石子，比如只有第一级有石子，我将第一级的石子移动到地面，我就赢了，所以真正影响胜负的是奇数级台阶的石子。

#### 代码

```c++
#include<iostream>
#include<algorithm>

using namespace std;

int main(){
    int n;
    cin >> n;
    int res = 0;
    
    for(int i = 1;i <= n;i++){
        int x;
        cin >> x;
        if(i % 2 == 1) res ^= x; //只把奇数阶的石子进行异或
    }
    
    if(res) cout << "Yes" << endl;
    else puts("No");
    
    return 0;
}
```





